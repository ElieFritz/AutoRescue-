-- ============================================
-- AUTORESCUE - SCHÉMA DE BASE DE DONNÉES
-- Migration: 001_initial_schema
-- ============================================

-- Extensions nécessaires
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "postgis";

-- ============================================
-- ÉNUMÉRATIONS
-- ============================================

CREATE TYPE user_role AS ENUM ('motorist', 'garage', 'mechanic', 'admin');

CREATE TYPE breakdown_status AS ENUM (
    'pending',
    'accepted',
    'mechanic_assigned',
    'mechanic_on_way',
    'mechanic_arrived',
    'diagnosing',
    'quote_sent',
    'quote_accepted',
    'repairing',
    'completed',
    'cancelled'
);

CREATE TYPE payment_status AS ENUM ('pending', 'processing', 'completed', 'failed', 'refunded');
CREATE TYPE payment_type AS ENUM ('diagnostic', 'repair');

-- ============================================
-- TABLE: users
-- ============================================

CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL UNIQUE,
    phone VARCHAR(20),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    avatar_url TEXT,
    role user_role NOT NULL DEFAULT 'motorist',
    is_active BOOLEAN NOT NULL DEFAULT true,
    is_verified BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_phone ON users(phone);

-- ============================================
-- TABLE: vehicles
-- ============================================

CREATE TABLE IF NOT EXISTS vehicles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    brand VARCHAR(100) NOT NULL,
    model VARCHAR(100) NOT NULL,
    year INTEGER NOT NULL CHECK (year >= 1900 AND year <= EXTRACT(YEAR FROM NOW()) + 1),
    license_plate VARCHAR(20) NOT NULL,
    color VARCHAR(50),
    vin VARCHAR(17),
    fuel_type VARCHAR(50),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_vehicles_user ON vehicles(user_id);
CREATE UNIQUE INDEX idx_vehicles_plate ON vehicles(license_plate);

-- ============================================
-- TABLE: garages
-- ============================================

CREATE TABLE IF NOT EXISTS garages (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    address VARCHAR(500) NOT NULL,
    city VARCHAR(100) NOT NULL,
    postal_code VARCHAR(20),
    country VARCHAR(100) NOT NULL DEFAULT 'Cameroon',
    latitude DECIMAL(10, 8) NOT NULL,
    longitude DECIMAL(11, 8) NOT NULL,
    location GEOGRAPHY(POINT, 4326),
    phone VARCHAR(20) NOT NULL,
    email VARCHAR(255),
    logo_url TEXT,
    cover_url TEXT,
    is_active BOOLEAN NOT NULL DEFAULT true,
    is_verified BOOLEAN NOT NULL DEFAULT false,
    rating DECIMAL(3, 2) NOT NULL DEFAULT 0.00 CHECK (rating >= 0 AND rating <= 5),
    total_reviews INTEGER NOT NULL DEFAULT 0,
    diagnostic_fee DECIMAL(10, 2) NOT NULL DEFAULT 5000.00,
    travel_fee_per_km DECIMAL(10, 2) NOT NULL DEFAULT 500.00,
    max_travel_distance INTEGER NOT NULL DEFAULT 50,
    opening_hours JSONB,
    services TEXT[],
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_garages_user ON garages(user_id);
CREATE INDEX idx_garages_city ON garages(city);
CREATE INDEX idx_garages_active ON garages(is_active);
CREATE INDEX idx_garages_location ON garages USING GIST(location);

-- Trigger pour mettre à jour automatiquement la colonne location
CREATE OR REPLACE FUNCTION update_garage_location()
RETURNS TRIGGER AS $$
BEGIN
    NEW.location := ST_SetSRID(ST_MakePoint(NEW.longitude, NEW.latitude), 4326)::geography;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_garage_location
    BEFORE INSERT OR UPDATE OF latitude, longitude ON garages
    FOR EACH ROW
    EXECUTE FUNCTION update_garage_location();

-- ============================================
-- TABLE: mechanics
-- ============================================

CREATE TABLE IF NOT EXISTS mechanics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    garage_id UUID NOT NULL REFERENCES garages(id) ON DELETE CASCADE,
    specializations TEXT[],
    is_available BOOLEAN NOT NULL DEFAULT true,
    current_latitude DECIMAL(10, 8),
    current_longitude DECIMAL(11, 8),
    current_location GEOGRAPHY(POINT, 4326),
    last_location_update TIMESTAMPTZ,
    rating DECIMAL(3, 2) NOT NULL DEFAULT 0.00 CHECK (rating >= 0 AND rating <= 5),
    total_jobs INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_mechanics_user ON mechanics(user_id);
CREATE INDEX idx_mechanics_garage ON mechanics(garage_id);
CREATE INDEX idx_mechanics_available ON mechanics(is_available);
CREATE INDEX idx_mechanics_location ON mechanics USING GIST(current_location);

-- Trigger pour mettre à jour automatiquement la colonne current_location
CREATE OR REPLACE FUNCTION update_mechanic_location()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.current_latitude IS NOT NULL AND NEW.current_longitude IS NOT NULL THEN
        NEW.current_location := ST_SetSRID(ST_MakePoint(NEW.current_longitude, NEW.current_latitude), 4326)::geography;
        NEW.last_location_update := NOW();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_mechanic_location
    BEFORE INSERT OR UPDATE OF current_latitude, current_longitude ON mechanics
    FOR EACH ROW
    EXECUTE FUNCTION update_mechanic_location();

-- ============================================
-- TABLE: breakdowns
-- ============================================

CREATE TABLE IF NOT EXISTS breakdowns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    motorist_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    vehicle_id UUID NOT NULL REFERENCES vehicles(id) ON DELETE CASCADE,
    garage_id UUID REFERENCES garages(id) ON DELETE SET NULL,
    mechanic_id UUID REFERENCES mechanics(id) ON DELETE SET NULL,
    status breakdown_status NOT NULL DEFAULT 'pending',
    latitude DECIMAL(10, 8) NOT NULL,
    longitude DECIMAL(11, 8) NOT NULL,
    location GEOGRAPHY(POINT, 4326),
    address TEXT,
    description TEXT NOT NULL,
    problem_type VARCHAR(100),
    photos TEXT[],
    distance_to_garage DECIMAL(10, 2),
    estimated_arrival TIMESTAMPTZ,
    diagnostic_fee DECIMAL(10, 2),
    travel_fee DECIMAL(10, 2),
    total_initial_fee DECIMAL(10, 2),
    quote_amount DECIMAL(10, 2),
    quote_description TEXT,
    final_amount DECIMAL(10, 2),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    accepted_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ
);

CREATE INDEX idx_breakdowns_motorist ON breakdowns(motorist_id);
CREATE INDEX idx_breakdowns_garage ON breakdowns(garage_id);
CREATE INDEX idx_breakdowns_mechanic ON breakdowns(mechanic_id);
CREATE INDEX idx_breakdowns_status ON breakdowns(status);
CREATE INDEX idx_breakdowns_created ON breakdowns(created_at DESC);
CREATE INDEX idx_breakdowns_location ON breakdowns USING GIST(location);

-- Trigger pour mettre à jour automatiquement la colonne location
CREATE OR REPLACE FUNCTION update_breakdown_location()
RETURNS TRIGGER AS $$
BEGIN
    NEW.location := ST_SetSRID(ST_MakePoint(NEW.longitude, NEW.latitude), 4326)::geography;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_breakdown_location
    BEFORE INSERT OR UPDATE OF latitude, longitude ON breakdowns
    FOR EACH ROW
    EXECUTE FUNCTION update_breakdown_location();

-- ============================================
-- TABLE: payments
-- ============================================

CREATE TABLE IF NOT EXISTS payments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    breakdown_id UUID NOT NULL REFERENCES breakdowns(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    type payment_type NOT NULL,
    amount DECIMAL(10, 2) NOT NULL CHECK (amount > 0),
    currency VARCHAR(3) NOT NULL DEFAULT 'XAF',
    status payment_status NOT NULL DEFAULT 'pending',
    provider VARCHAR(50) NOT NULL DEFAULT 'notchpay',
    provider_reference VARCHAR(255),
    provider_transaction_id VARCHAR(255),
    metadata JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMPTZ
);

CREATE INDEX idx_payments_breakdown ON payments(breakdown_id);
CREATE INDEX idx_payments_user ON payments(user_id);
CREATE INDEX idx_payments_status ON payments(status);
CREATE INDEX idx_payments_provider_ref ON payments(provider_reference);

-- ============================================
-- TABLE: reports
-- ============================================

CREATE TABLE IF NOT EXISTS reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    breakdown_id UUID NOT NULL REFERENCES breakdowns(id) ON DELETE CASCADE,
    mechanic_id UUID NOT NULL REFERENCES mechanics(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL, -- 'diagnostic', 'quote', 'final'
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    photos TEXT[],
    parts_used JSONB,
    labor_hours DECIMAL(5, 2),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_reports_breakdown ON reports(breakdown_id);
CREATE INDEX idx_reports_mechanic ON reports(mechanic_id);
CREATE INDEX idx_reports_type ON reports(type);

-- ============================================
-- TABLE: reviews
-- ============================================

CREATE TABLE IF NOT EXISTS reviews (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    breakdown_id UUID NOT NULL REFERENCES breakdowns(id) ON DELETE CASCADE,
    reviewer_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    reviewed_garage_id UUID REFERENCES garages(id) ON DELETE SET NULL,
    reviewed_mechanic_id UUID REFERENCES mechanics(id) ON DELETE SET NULL,
    rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
    comment TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(breakdown_id, reviewer_id)
);

CREATE INDEX idx_reviews_garage ON reviews(reviewed_garage_id);
CREATE INDEX idx_reviews_mechanic ON reviews(reviewed_mechanic_id);

-- ============================================
-- TABLE: notifications
-- ============================================

CREATE TABLE IF NOT EXISTS notifications (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    title VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    data JSONB,
    is_read BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_notifications_user ON notifications(user_id);
CREATE INDEX idx_notifications_read ON notifications(is_read);
CREATE INDEX idx_notifications_created ON notifications(created_at DESC);

-- ============================================
-- TABLE: refresh_tokens
-- ============================================

CREATE TABLE IF NOT EXISTS refresh_tokens (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    revoked_at TIMESTAMPTZ
);

CREATE INDEX idx_refresh_tokens_user ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_hash ON refresh_tokens(token_hash);

-- ============================================
-- FONCTIONS UTILITAIRES
-- ============================================

-- Fonction de calcul de distance Haversine
CREATE OR REPLACE FUNCTION calculate_distance(
    lat1 DECIMAL,
    lng1 DECIMAL,
    lat2 DECIMAL,
    lng2 DECIMAL
) RETURNS DECIMAL AS $$
DECLARE
    earth_radius CONSTANT DECIMAL := 6371; -- km
    dlat DECIMAL;
    dlng DECIMAL;
    a DECIMAL;
    c DECIMAL;
BEGIN
    dlat := RADIANS(lat2 - lat1);
    dlng := RADIANS(lng2 - lng1);
    
    a := SIN(dlat / 2) * SIN(dlat / 2) +
         COS(RADIANS(lat1)) * COS(RADIANS(lat2)) *
         SIN(dlng / 2) * SIN(dlng / 2);
    
    c := 2 * ATAN2(SQRT(a), SQRT(1 - a));
    
    RETURN earth_radius * c;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Fonction pour trouver les garages à proximité
CREATE OR REPLACE FUNCTION nearby_garages(
    user_lat DECIMAL,
    user_lng DECIMAL,
    max_distance_km DECIMAL DEFAULT 50
)
RETURNS TABLE (
    id UUID,
    name VARCHAR,
    address VARCHAR,
    city VARCHAR,
    latitude DECIMAL,
    longitude DECIMAL,
    phone VARCHAR,
    logo_url TEXT,
    rating DECIMAL,
    diagnostic_fee DECIMAL,
    travel_fee_per_km DECIMAL,
    distance_km DECIMAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        g.id,
        g.name,
        g.address,
        g.city,
        g.latitude,
        g.longitude,
        g.phone,
        g.logo_url,
        g.rating,
        g.diagnostic_fee,
        g.travel_fee_per_km,
        ROUND(calculate_distance(user_lat, user_lng, g.latitude, g.longitude)::DECIMAL, 2) as distance_km
    FROM garages g
    WHERE g.is_active = true
      AND g.is_verified = true
      AND calculate_distance(user_lat, user_lng, g.latitude, g.longitude) <= max_distance_km
      AND calculate_distance(user_lat, user_lng, g.latitude, g.longitude) <= g.max_travel_distance
    ORDER BY distance_km ASC;
END;
$$ LANGUAGE plpgsql STABLE;

-- Fonction pour mettre à jour updated_at automatiquement
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Appliquer le trigger updated_at à toutes les tables
CREATE TRIGGER set_updated_at_users BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER set_updated_at_vehicles BEFORE UPDATE ON vehicles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER set_updated_at_garages BEFORE UPDATE ON garages FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER set_updated_at_mechanics BEFORE UPDATE ON mechanics FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER set_updated_at_breakdowns BEFORE UPDATE ON breakdowns FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER set_updated_at_payments BEFORE UPDATE ON payments FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER set_updated_at_reports BEFORE UPDATE ON reports FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Fonction pour mettre à jour les ratings des garages
CREATE OR REPLACE FUNCTION update_garage_rating()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE garages
    SET 
        rating = (
            SELECT COALESCE(AVG(rating), 0)
            FROM reviews
            WHERE reviewed_garage_id = NEW.reviewed_garage_id
        ),
        total_reviews = (
            SELECT COUNT(*)
            FROM reviews
            WHERE reviewed_garage_id = NEW.reviewed_garage_id
        )
    WHERE id = NEW.reviewed_garage_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_garage_rating
    AFTER INSERT OR UPDATE OR DELETE ON reviews
    FOR EACH ROW
    WHEN (NEW.reviewed_garage_id IS NOT NULL OR OLD.reviewed_garage_id IS NOT NULL)
    EXECUTE FUNCTION update_garage_rating();

-- Fonction pour mettre à jour les ratings des mécaniciens
CREATE OR REPLACE FUNCTION update_mechanic_rating()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE mechanics
    SET 
        rating = (
            SELECT COALESCE(AVG(rating), 0)
            FROM reviews
            WHERE reviewed_mechanic_id = NEW.reviewed_mechanic_id
        ),
        total_jobs = (
            SELECT COUNT(*)
            FROM reviews
            WHERE reviewed_mechanic_id = NEW.reviewed_mechanic_id
        )
    WHERE id = NEW.reviewed_mechanic_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_mechanic_rating
    AFTER INSERT OR UPDATE OR DELETE ON reviews
    FOR EACH ROW
    WHEN (NEW.reviewed_mechanic_id IS NOT NULL OR OLD.reviewed_mechanic_id IS NOT NULL)
    EXECUTE FUNCTION update_mechanic_rating();
