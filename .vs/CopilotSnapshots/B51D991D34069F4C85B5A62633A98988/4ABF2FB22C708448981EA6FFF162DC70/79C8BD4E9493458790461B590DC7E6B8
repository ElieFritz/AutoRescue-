import { Injectable, NotFoundException, ForbiddenException, BadRequestException } from '@nestjs/common';
import { SupabaseService } from '../../database/supabase.service';

@Injectable()
export class BreakdownsService {
  constructor(private readonly supabase: SupabaseService) {}

  async findAll(userId: string, role: string) {
    let query = this.supabase.admin
      .from('breakdowns')
      .select('*, motorist:profiles!motorist_id(*), vehicle:vehicles(*), garage:garages(*)')
      .order('created_at', { ascending: false });

    if (role === 'motorist') {
      query = query.eq('motorist_id', userId);
    }

    const { data, error } = await query;
    if (error) {
      console.error('Error fetching breakdowns:', error);
      return [];
    }
    return data || [];
  }

  async findOne(id: string) {
    const { data, error } = await this.supabase.admin
      .from('breakdowns')
      .select('*, motorist:profiles!motorist_id(*), vehicle:vehicles(*), garage:garages(*), mechanic:mechanics(*)')
      .eq('id', id)
      .single();

    if (error || !data) throw new NotFoundException('Demande non trouvee');
    return data;
  }

  async create(motoristId: string, createData: any) {
    // Map frontend fields to database fields
    const insertData: any = {
      motorist_id: motoristId,
      status: 'pending',
      title: createData.title || 'Demande de depannage',
      description: createData.description || '',
      breakdown_type: createData.breakdownType || createData.breakdown_type || 'other',
      latitude: createData.latitude || createData.location?.lat,
      longitude: createData.longitude || createData.location?.lng,
      address: createData.address || createData.location?.address || '',
    };

    // Optional fields
    if (createData.vehicleId || createData.vehicle_id) {
      insertData.vehicle_id = createData.vehicleId || createData.vehicle_id;
    }
    if (createData.garageId || createData.garage_id) {
      insertData.garage_id = createData.garageId || createData.garage_id;
    }
    if (createData.photos) {
      insertData.photos = createData.photos;
    }

    console.log('Creating breakdown with data:', insertData);

    const { data, error } = await this.supabase.admin
      .from('breakdowns')
      .insert(insertData)
      .select()
      .single();

    if (error) {
      console.error('Error creating breakdown:', error);
      throw new BadRequestException(error.message);
    }
    return data;
  }

  async updateStatus(id: string, status: string, userId: string) {
    const { data, error } = await this.supabase.admin
      .from('breakdowns')
      .update({ status })
      .eq('id', id)
      .select()
      .single();

    if (error) {
      console.error('Error updating status:', error);
      throw new BadRequestException(error.message);
    }
    return data;
  }

  async accept(id: string, garageId: string) {
    const { data, error } = await this.supabase.admin
      .from('breakdowns')
      .update({
        garage_id: garageId,
        status: 'accepted',
        accepted_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single();

    if (error) {
      console.error('Error accepting breakdown:', error);
      throw new BadRequestException(error.message);
    }
    return data;
  }

  async cancel(id: string, userId: string, reason: string) {
    const { data, error } = await this.supabase.admin
      .from('breakdowns')
      .update({
        status: 'cancelled',
        cancelled_by: userId,
        cancellation_reason: reason
      })
      .eq('id', id)
      .select()
      .single();

    if (error) {
      console.error('Error cancelling breakdown:', error);
      throw new BadRequestException(error.message);
    }
    return data;
  }
}
